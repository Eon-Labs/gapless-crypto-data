{
  "api_data": {
    "decorators": {},
    "docstrings": {
      "AtomicCSVOperations": {
        "raw": "Safe atomic operations for CSV files with header preservation",
        "sections": {},
        "summary": "Safe atomic operations for CSV files with header preservation"
      },
      "BinancePublicDataCollector": {
        "raw": "Ultra-fast spot data collection using Binance's public data repository.",
        "sections": {},
        "summary": "Ultra-fast spot data collection using Binance's public data repository."
      },
      "SafeCSVMerger": {
        "raw": "Safe CSV data merging with gap filling capabilities",
        "sections": {},
        "summary": "Safe CSV data merging with gap filling capabilities"
      },
      "UniversalGapFiller": {
        "raw": "Universal gap detection and filling for all timeframes with authentic 11-column microstructure format",
        "sections": {},
        "summary": "Universal gap detection and filling for all timeframes with authentic 11-column microstructure format"
      }
    },
    "inheritance": {
      "AtomicCSVOperations": {
        "bases": [
          "object"
        ],
        "mro": [
          "AtomicCSVOperations",
          "object"
        ],
        "subclasses": []
      },
      "BinancePublicDataCollector": {
        "bases": [
          "object"
        ],
        "mro": [
          "BinancePublicDataCollector",
          "object"
        ],
        "subclasses": []
      },
      "SafeCSVMerger": {
        "bases": [
          "object"
        ],
        "mro": [
          "SafeCSVMerger",
          "object"
        ],
        "subclasses": []
      },
      "UniversalGapFiller": {
        "bases": [
          "object"
        ],
        "mro": [
          "UniversalGapFiller",
          "object"
        ],
        "subclasses": []
      }
    },
    "package_info": {
      "all": [
        "BinancePublicDataCollector",
        "UniversalGapFiller",
        "AtomicCSVOperations",
        "SafeCSVMerger"
      ],
      "doc": "Gapless Crypto Data - Ultra-fast USDT spot market data collection with zero gaps guarantee\n\nMarket Compatibility:\n- \ud83c\udfaf USDT SPOT PAIRS ONLY (BTCUSDT, ETHUSDT, SOLUSDT, etc.)\n- \u274c NO futures, perpetuals, or derivatives support\n- \u274c NO non-USDT pairs (BTC/ETH, etc.)\n- \u274c NO margin trading data\n\nCore Features:\n- \ud83d\ude80 22x faster than API calls via Binance public data repository\n- \ud83d\udcca Full 11-column microstructure format with order flow and liquidity metrics\n- \ud83d\udd12 Zero gaps guarantee through authentic API-first validation\n- \u26a1 UV-first modern Python tooling\n- \ud83d\udee1\ufe0f Corruption-proof atomic file operations\n- \ud83d\udcca Multi-timeframe support (1m, 3m, 5m, 15m, 30m, 1h, 2h, 4h)\n- \ud83d\udd27 Gap detection and filling with authentic data only\n- \ud83d\udcc8 Production-grade data collection for quantitative trading\n\nData Source:\n    Binance Spot Market: https://data.binance.vision/data/spot/monthly/klines/\n    Market Type: SPOT only (no futures/derivatives)\n    Supported Pairs: USDT-quoted spot pairs exclusively\n\nUsage:\n    from gapless_crypto_data import BinancePublicDataCollector, UniversalGapFiller\n\n    # Collect USDT spot data only\n    collector = BinancePublicDataCollector()\n    collector.collect_data(\n        symbol=\"SOLUSDT\",  # USDT spot pairs only\n        timeframes=[\"1m\", \"5m\", \"1h\"],\n        start_date=\"2023-01-01\",\n        end_date=\"2023-12-31\"\n    )\n\n    # Fill gaps with authentic spot data\n    gap_filler = UniversalGapFiller()\n    gap_filler.fill_gaps(directory=\"./data\")\n\nCLI Usage:\n    uv run gapless-crypto-data --symbol SOLUSDT --timeframes 1m,3m,5m\n    uv run gapless-crypto-data --fill-gaps --directory ./data\n\nSupported Symbols (USDT Spot Only):\n    BTCUSDT, ETHUSDT, SOLUSDT, ADAUSDT, DOTUSDT, LINKUSDT, MATICUSDT,\n    AVAXUSDT, ATOMUSDT, NEARUSDT, FTMUSDT, SANDUSDT, MANAUSDT, etc.",
      "file": "/Users/terryli/eon/gapless-crypto-data/src/gapless_crypto_data/__init__.py",
      "name": "gapless_crypto_data",
      "version": "2.2.0"
    },
    "public_api": {
      "AtomicCSVOperations": {
        "base_classes": [
          "object"
        ],
        "class_methods": {},
        "class_variables": {},
        "descriptors": {},
        "doc": "Safe atomic operations for CSV files with header preservation",
        "is_public": true,
        "line_number": 27,
        "methods": {
          "cleanup_backup": {
            "defined_in": "AtomicCSVOperations",
            "doc": "Remove backup file after successful operation",
            "name": "cleanup_backup",
            "signature": "(self) -> bool"
          },
          "create_backup": {
            "defined_in": "AtomicCSVOperations",
            "doc": "Create timestamped backup of original file",
            "name": "create_backup",
            "signature": "(self) -> pathlib._local.Path"
          },
          "read_header_comments": {
            "defined_in": "AtomicCSVOperations",
            "doc": "Extract header comments from CSV file",
            "name": "read_header_comments",
            "signature": "(self) -> List[str]"
          },
          "rollback_from_backup": {
            "defined_in": "AtomicCSVOperations",
            "doc": "Restore file from backup in case of failure",
            "name": "rollback_from_backup",
            "signature": "(self) -> bool"
          },
          "validate_dataframe": {
            "defined_in": "AtomicCSVOperations",
            "doc": "Validate DataFrame integrity before writing",
            "name": "validate_dataframe",
            "signature": "(self, df: pandas.core.frame.DataFrame) -> Tuple[bool, str]"
          },
          "write_dataframe_atomic": {
            "defined_in": "AtomicCSVOperations",
            "doc": "Write DataFrame to CSV using atomic operations",
            "name": "write_dataframe_atomic",
            "signature": "(self, df: pandas.core.frame.DataFrame, header_comments: Optional[List[str]] = None) -> bool"
          }
        },
        "module": "gapless_crypto_data.gap_filling.safe_file_operations",
        "mro": [
          "AtomicCSVOperations",
          "object"
        ],
        "name": "AtomicCSVOperations",
        "properties": {},
        "qualname": "AtomicCSVOperations",
        "signature": null,
        "source_file": "/Users/terryli/eon/gapless-crypto-data/src/gapless_crypto_data/gap_filling/safe_file_operations.py",
        "static_methods": {},
        "type": "class"
      },
      "BinancePublicDataCollector": {
        "base_classes": [
          "object"
        ],
        "class_methods": {},
        "class_variables": {},
        "descriptors": {},
        "doc": "Ultra-fast spot data collection using Binance's public data repository.",
        "is_public": true,
        "line_number": 39,
        "methods": {
          "apply_gap_filling_to_validated_files": {
            "defined_in": "BinancePublicDataCollector",
            "doc": "Apply comprehensive gap filling to validated data files using authentic Binance API data",
            "name": "apply_gap_filling_to_validated_files",
            "signature": "(self)"
          },
          "collect_multiple_timeframes": {
            "defined_in": "BinancePublicDataCollector",
            "doc": "Collect data for multiple timeframes with full 11-column microstructure format.",
            "name": "collect_multiple_timeframes",
            "signature": "(self, timeframes=None)"
          },
          "collect_timeframe_data": {
            "defined_in": "BinancePublicDataCollector",
            "doc": "Collect complete historical data for a single timeframe with full 11-column microstructure format.",
            "name": "collect_timeframe_data",
            "signature": "(self, trading_timeframe)"
          },
          "download_and_extract_month": {
            "defined_in": "BinancePublicDataCollector",
            "doc": "Download and extract a single monthly ZIP file.",
            "name": "download_and_extract_month",
            "signature": "(self, binance_zip_url, zip_filename)"
          },
          "generate_metadata": {
            "defined_in": "BinancePublicDataCollector",
            "doc": "Generate comprehensive metadata for 11-column microstructure format.",
            "name": "generate_metadata",
            "signature": "(self, trading_timeframe, candle_data, collection_performance_stats, gap_analysis_result=None)"
          },
          "generate_monthly_urls": {
            "defined_in": "BinancePublicDataCollector",
            "doc": "Generate list of monthly ZIP file URLs to download.",
            "name": "generate_monthly_urls",
            "signature": "(self, trading_timeframe)"
          },
          "process_raw_data": {
            "defined_in": "BinancePublicDataCollector",
            "doc": "Convert raw Binance CSV data with comprehensive timestamp format tracking and transition detection.",
            "name": "process_raw_data",
            "signature": "(self, raw_csv_data)"
          },
          "save_to_csv": {
            "defined_in": "BinancePublicDataCollector",
            "doc": "Save data to CSV file with full 11-column microstructure format and metadata.",
            "name": "save_to_csv",
            "signature": "(self, timeframe, data, collection_stats)"
          },
          "update_metadata_with_validation": {
            "defined_in": "BinancePublicDataCollector",
            "doc": "Update metadata JSON file with validation results.",
            "name": "update_metadata_with_validation",
            "signature": "(self, csv_filepath, validation_results)"
          },
          "validate_csv_file": {
            "defined_in": "BinancePublicDataCollector",
            "doc": "Comprehensive validation of CSV file data integrity, completeness, and quality.\n\nArgs:\n    csv_filepath: Path to CSV file to validate\n    expected_timeframe: Expected timeframe (e.g., '30m') for interval validation\n\nReturns:\n    dict: Validation results with detailed analysis",
            "name": "validate_csv_file",
            "signature": "(self, csv_filepath, expected_timeframe=None)"
          }
        },
        "module": "gapless_crypto_data.collectors.binance_public_data_collector",
        "mro": [
          "BinancePublicDataCollector",
          "object"
        ],
        "name": "BinancePublicDataCollector",
        "properties": {},
        "qualname": "BinancePublicDataCollector",
        "signature": null,
        "source_file": "/Users/terryli/eon/gapless-crypto-data/src/gapless_crypto_data/collectors/binance_public_data_collector.py",
        "static_methods": {},
        "type": "class"
      },
      "SafeCSVMerger": {
        "base_classes": [
          "object"
        ],
        "class_methods": {},
        "class_variables": {},
        "descriptors": {},
        "doc": "Safe CSV data merging with gap filling capabilities",
        "is_public": true,
        "line_number": 179,
        "methods": {
          "merge_gap_data_safe": {
            "defined_in": "SafeCSVMerger",
            "doc": "Safely merge gap data into existing CSV using atomic operations",
            "name": "merge_gap_data_safe",
            "signature": "(self, gap_data: pandas.core.frame.DataFrame, gap_start: datetime.datetime, gap_end: datetime.datetime) -> bool"
          }
        },
        "module": "gapless_crypto_data.gap_filling.safe_file_operations",
        "mro": [
          "SafeCSVMerger",
          "object"
        ],
        "name": "SafeCSVMerger",
        "properties": {},
        "qualname": "SafeCSVMerger",
        "signature": null,
        "source_file": "/Users/terryli/eon/gapless-crypto-data/src/gapless_crypto_data/gap_filling/safe_file_operations.py",
        "static_methods": {},
        "type": "class"
      },
      "UniversalGapFiller": {
        "base_classes": [
          "object"
        ],
        "class_methods": {},
        "class_variables": {},
        "descriptors": {},
        "doc": "Universal gap detection and filling for all timeframes with authentic 11-column microstructure format",
        "is_public": true,
        "line_number": 34,
        "methods": {
          "detect_all_gaps": {
            "defined_in": "UniversalGapFiller",
            "doc": "Detect ALL gaps in CSV file by analyzing timestamp sequence for 11-column format",
            "name": "detect_all_gaps",
            "signature": "(self, csv_path: pathlib._local.Path, timeframe: str) -> List[Dict]"
          },
          "extract_symbol_from_filename": {
            "defined_in": "UniversalGapFiller",
            "doc": "Extract symbol from CSV filename\n\nSupports formats like:\n- binance_spot_BTCUSDT-1h_20240101-20240101_0.0y.csv\n- BTCUSDT_1h_data.csv\n- ETHUSDT-4h.csv",
            "name": "extract_symbol_from_filename",
            "signature": "(self, csv_path: pathlib._local.Path) -> str"
          },
          "fetch_binance_data": {
            "defined_in": "UniversalGapFiller",
            "doc": "Fetch authentic microstructure data from Binance API - NO synthetic data",
            "name": "fetch_binance_data",
            "signature": "(self, start_time: datetime.datetime, end_time: datetime.datetime, timeframe: str, symbol: str, enhanced_format: bool = False) -> Optional[List[Dict]]"
          },
          "fill_gap": {
            "defined_in": "UniversalGapFiller",
            "doc": "Fill a single gap with authentic Binance data using API-first validation protocol",
            "name": "fill_gap",
            "signature": "(self, timestamp_gap_info: Dict, csv_path: pathlib._local.Path, trading_timeframe: str, metadata_path: pathlib._local.Path = None) -> bool"
          },
          "process_file": {
            "defined_in": "UniversalGapFiller",
            "doc": "Process a single CSV file - detect and fill ALL gaps",
            "name": "process_file",
            "signature": "(self, csv_path: pathlib._local.Path, trading_timeframe: str) -> Dict"
          }
        },
        "module": "gapless_crypto_data.gap_filling.universal_gap_filler",
        "mro": [
          "UniversalGapFiller",
          "object"
        ],
        "name": "UniversalGapFiller",
        "properties": {},
        "qualname": "UniversalGapFiller",
        "signature": null,
        "source_file": "/Users/terryli/eon/gapless-crypto-data/src/gapless_crypto_data/gap_filling/universal_gap_filler.py",
        "static_methods": {},
        "type": "class"
      }
    },
    "signatures": {
      "AtomicCSVOperations": "(csv_path: pathlib._local.Path)",
      "BinancePublicDataCollector": "(symbol='SOLUSDT', start_date='2020-08-15', end_date='2025-03-20', output_dir=None)",
      "SafeCSVMerger": "(csv_path: pathlib._local.Path)",
      "UniversalGapFiller": "()"
    },
    "type_hints": {
      "AtomicCSVOperations": {
        "annotations": {}
      },
      "BinancePublicDataCollector": {
        "annotations": {}
      },
      "SafeCSVMerger": {
        "annotations": {}
      },
      "UniversalGapFiller": {
        "annotations": {}
      }
    }
  },
  "metadata": {
    "package_name": "gapless_crypto_data",
    "snapshot_format_version": "1.0",
    "total_elements": 4
  },
  "signature_hashes": {
    "AtomicCSVOperations": "c90f35226ff9ba43f87345716de6a68fdfd2520b7667c3505367c1c89d2a729f",
    "BinancePublicDataCollector": "ed70c2886c68221ced437a2149505869dfcfbdd1560a0b503d63ccadd5f113c4",
    "SafeCSVMerger": "168201fcb39d43ff2df85bb11bee2052fd8e0d3f24843d1706b5803fd1621ca8",
    "UniversalGapFiller": "9c44b1fee8aca97e49b89bb0889dfc9cb3a7bf439726c9aeeabd75a7d5469f56"
  },
  "timestamp": "2025-09-16T18:32:40.337906",
  "version": "2.2.0"
}